Recovered Plaintext: // Lab 02. Affine Cipher// By: Lopez Reyes Jose Roberto and Hernandez Zamora Alejandro. 6CV4.#include <iostream>#include <vector>#include <string>#include <map>#include <numeric>#include <algorithm>#include <cstdlib>#include <ctime>#include <fstream>using namespace std;vector<char> alphabetVector;map<char, int> alphabetMap;// Fills with the ASCII characters manuallyvoid fill_alphabet(){    for (int i = 32; i <= 126; ++i)    {        alphabetVector.push_back(static_cast<char>(i));        alphabetMap[(char)i] = alphabetVector.size() - 1;    }}// Greatest Common Divisorint gcd(int a, int b){    while (b != 0)    {        int temp = b;        b = a % b;        a = temp;    }    return a;}// Returns the Z*n setvector<int> Zestrella(int n){    if (n < 2)    {        cout << "Your number needs to be greater or equal to 2.\n";        return {};    }    vector<int> result;    for (int a = 1; a < n; a++)    {        if (gcd(a, n) == 1)        {            result.push_back(a);        }    }    return result;}// Finding b such that ab mod n = 1int find_b(int n, int a){    int b;    vector<int> Zn = Zestrella(n);    if (n < 2 || find(Zn.begin(), Zn.end(), a) == Zn.end())    {        cout << "\nAn error occured that can't let the program continue.\n";        return -1;    }    for (int i = 0; i < Zn.size(); i++)    {        if (((a * Zn[i]) % n) == 1)        {            b = Zn[i];            break;        }    }    return b;}// Key Generatorvector<int> key_gen(int n){    vector<int> key(2);    int a, b;    vector<int> Zn = Zestrella(n);    a = Zn[rand() % Zn.size()];    b = rand() % n;    key[0] = a;    key[1] = b;    return key;}// Affine Cipher Encipheringstring encipher(string M, vector<int> K){    string C = "";    int n = alphabetVector.size();    for (char mi : M)    {        auto codificated = alphabetMap.find(mi);        if (codificated == alphabetMap.end())        {            return "There's a character that doesn't belong in the alphabet.";        }        int ci = ((K[0] * codificated->second) + K[1]) % n;        C += alphabetVector[ci];    }    return C;}// Affine Cipher Decipheringstring decipher(string C, vector<int> K){    string M = "";    int n = alphabetVector.size();    for (char ci : C)    {        auto decodificated = alphabetMap.find(ci);        if (decodificated == alphabetMap.end())        {            return "There's a character that doesn't belong in the alphabet.";        }        int mi = (decodificated->second - K[1]) * find_b(n, K[0]);        if (mi < 0)        {            mi = (mi % n + n) % n;        }        else        {            mi = mi % n;        }        M += alphabetVector[mi];    }    return M;}// Generate all possible keysvoid gen_all_keys(int n, ofstream &outFile){    vector<int> Zn = Zestrella(n);    outFile << "All possible keys for n = " << n << ":\n";    for (int a : Zn)    {        for (int b = 0; b < n; ++b)        {            outFile << "(" << a << ", " << b << ")\n";            outFile << find_b(n, a) << " mod " << n << " = " << (find_b(n, a)) % n << "\n";        }    }}// Function for the Ciphering Personvoid bob(int n){    cout << "--- Ciphering ---\n";    string M;    cout << "Insert the plaintext: ";    getline(cin, M);    vector<int> K = key_gen(n);    string C = encipher(M, K);        ofstream keyFile("key.txt");    if (!keyFile.is_open()) {        cerr << "Error: Could not open key.txt for writing.\n";        return;    }    keyFile << K[0] << " " << K[1];    keyFile.close();    ofstream cipherFile("ciphertext.txt");    if (!cipherFile.is_open()) {        cerr << "Error: Could not open ciphertext.txt for writing.\n";        return;    }    cipherFile << C;    cipherFile.close();    cout << "\nPlaintext ciphered successfully." << endl;    cout << "-> Key saved to key.txt" << endl;    cout << "-> Ciphertext saved to ciphertext.txt" << endl;    cout << "-----------------------\n\n";}// Function for the Deciphering Personvoid alice(int n){    cout << "--- Deciphering ---\n";    vector<int> K(2);    string C, M;    ifstream keyFile("key.txt");    if (!keyFile.is_open()) {        cerr << "Error: Could not find key.txt to read the key.\n";        return;    }    keyFile >> K[0] >> K[1];    keyFile.close();    cout << "-> Key (" << K[0] << ", " << K[1] << ") read from key.txt" << endl;    cout << "\nEnter the ciphered text to decipher: ";    getline(cin, C);    M = decipher(C, K);    ofstream resultFile("deciphered_text.txt");     if (!resultFile.is_open()) {        cerr << "Error: Could not open deciphered_text.txt for writing.\n";        return;    }    resultFile << "Recovered Plaintext: " << M;    resultFile.close();    cout << "\nText deciphered successfully." << endl;    cout << "-> Result saved to deciphered_text.txt" << endl;    cout << "-------------------------\n";}int main(){    srand(time(0));    fill_alphabet();    ofstream possibleKeys;    possibleKeys.open("possible_keys.txt");    int n = alphabetVector.size();    gen_all_keys(n, possibleKeys);    // Ciphering Person    bob(n);    // Deciphering Person    alice(n);    return 0;}